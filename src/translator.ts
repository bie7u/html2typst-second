import { parseDocument, DomUtils } from 'htmlparser2';
import { Document, Element, Text, Node, ChildNode } from 'domhandler';

/**
 * Context for rendering HTML nodes to Typst
 */
interface RenderContext {
  debug: boolean;
  styleStack: StyleContext[];
  listDepth: number;
  inListItem: boolean;
}

/**
 * Style context for tracking active styles
 */
interface StyleContext {
  bold?: boolean;
  italic?: boolean;
  underline?: boolean;
  strikethrough?: boolean;
  color?: string;
  fontSize?: string;
  fontFamily?: string;
}

/**
 * Translate HTML (generated by Quill.js) to Typst format
 * 
 * @param html - HTML string to convert
 * @param debug - Enable debug mode (includes diagnostic comments)
 * @returns Typst formatted string
 */
export function translateHtmlToTypst(html: string, debug: boolean = false): string {
  if (!html || html.trim().length === 0) {
    return '';
  }

  const document = parseDocument(html);
  const context: RenderContext = {
    debug,
    styleStack: [],
    listDepth: 0,
    inListItem: false,
  };

  const result = renderNode(document, context);
  // Only trim trailing whitespace to preserve indentation
  return result.replace(/\s+$/, '');
}

/**
 * Render a single node and its children
 */
function renderNode(node: Node, context: RenderContext): string {
  if (DomUtils.isText(node)) {
    return renderTextNode(node as Text, context);
  }

  if (DomUtils.isTag(node)) {
    return renderElementNode(node as Element, context);
  }

  if (DomUtils.isDocument(node)) {
    const doc = node as Document;
    return doc.children.map((child: ChildNode) => renderNode(child, context)).join('');
  }

  // Comments and other node types - render children if any
  if ('children' in node && Array.isArray(node.children)) {
    return (node.children as ChildNode[]).map((child: ChildNode) => renderNode(child, context)).join('');
  }

  return '';
}

/**
 * Render a text node with current styling
 */
function renderTextNode(node: Text, context: RenderContext): string {
  let text = node.data;
  
  // Don't render empty text nodes
  if (!text || text.trim().length === 0) {
    return text; // Keep whitespace as-is for spacing
  }

  const currentStyle = getCurrentStyle(context);
  
  // Apply styling
  if (currentStyle.bold) {
    text = `*${text}*`;
  }
  if (currentStyle.italic) {
    text = `_${text}_`;
  }
  
  return text;
}

/**
 * Render an HTML element node
 */
function renderElementNode(element: Element, context: RenderContext): string {
  const tagName = element.name.toLowerCase();
  
  // Handle different HTML tags
  switch (tagName) {
    case 'p':
    case 'div':
      return renderParagraph(element, context);
    
    case 'br':
      return '\n';
    
    case 'strong':
    case 'b':
      return renderWithStyle(element, context, { bold: true });
    
    case 'em':
    case 'i':
      return renderWithStyle(element, context, { italic: true });
    
    case 'u':
    case 's':
    case 'strike':
      // Ignore underline/strikethrough styling but preserve text
      return renderChildren(element, context);
    
    case 'h1':
    case 'h2':
    case 'h3':
    case 'h4':
    case 'h5':
    case 'h6':
      return renderHeading(element, context);
    
    case 'ul':
      return renderUnorderedList(element, context);
    
    case 'ol':
      return renderOrderedList(element, context);
    
    case 'li':
      return renderListItem(element, context);
    
    case 'blockquote':
      return renderBlockquote(element, context);
    
    case 'pre':
      return renderPreformatted(element, context);
    
    case 'code':
      return renderCode(element, context);
    
    case 'a':
      return renderLink(element, context);
    
    case 'img':
      return renderImage(element, context);
    
    case 'span':
      return renderSpan(element, context);
    
    default:
      // Unknown tag - report in debug mode and render children
      if (context.debug && !isCommonIgnoredTag(tagName)) {
        const childContent = renderChildren(element, context);
        return `/* Unsupported tag: ${tagName} */${childContent}`;
      }
      return renderChildren(element, context);
  }
}

/**
 * Check if a tag is commonly ignored (like html, body, head)
 */
function isCommonIgnoredTag(tagName: string): boolean {
  return ['html', 'body', 'head', 'meta', 'style', 'script'].includes(tagName);
}

/**
 * Render paragraph
 */
function renderParagraph(element: Element, context: RenderContext): string {
  const content = renderChildren(element, context);
  if (!content.trim()) {
    return '\n';
  }
  
  // Apply Quill.js alignment classes
  const alignment = getQuillAlignment(element);
  if (alignment) {
    return `#align(${alignment})[${content}]\n\n`;
  }
  
  return `${content}\n\n`;
}

/**
 * Render heading (h1-h6)
 */
function renderHeading(element: Element, context: RenderContext): string {
  const level = parseInt(element.name.charAt(1));
  const content = renderChildren(element, context);
  
  if (!content.trim()) {
    return '\n';
  }
  
  // Typst headings use = symbols
  const prefix = '='.repeat(level);
  return `${prefix} ${content}\n\n`;
}

/**
 * Render unordered list
 */
function renderUnorderedList(element: Element, context: RenderContext): string {
  const newContext = { ...context, listDepth: context.listDepth + 1 };
  const content = renderChildren(element, newContext);
  return `${content}\n`;
}

/**
 * Render ordered list
 */
function renderOrderedList(element: Element, context: RenderContext): string {
  const newContext = { ...context, listDepth: context.listDepth + 1 };
  const content = renderChildren(element, newContext);
  return `${content}\n`;
}

/**
 * Render list item
 */
function renderListItem(element: Element, context: RenderContext): string {
  const indent = getQuillIndent(element);
  // If we're inside a list (listDepth > 0), use listDepth + indent
  // Otherwise, use indent directly (for standalone li elements)
  const effectiveDepth = context.listDepth > 0 
    ? context.listDepth + indent 
    : Math.max(1, indent + 1);
  
  // Check if parent is ordered or unordered list
  const parent = element.parent;
  const isOrdered = parent && DomUtils.isTag(parent) && parent.name.toLowerCase() === 'ol';
  
  const marker = isOrdered ? '+' : '-';
  const indentation = '  '.repeat(effectiveDepth - 1);
  
  const newContext = { ...context, inListItem: true };
  const content = renderChildren(element, newContext).trim();
  
  return `${indentation}${marker} ${content}\n`;
}

/**
 * Render blockquote
 */
function renderBlockquote(element: Element, context: RenderContext): string {
  const content = renderChildren(element, context).trim();
  if (!content) {
    return '';
  }
  
  // Split by lines and add quote marker
  const lines = content.split('\n').filter(line => line.trim());
  return lines.map(line => `> ${line}`).join('\n') + '\n\n';
}

/**
 * Render preformatted text
 */
function renderPreformatted(element: Element, context: RenderContext): string {
  // Look for code element inside pre
  const codeElement = element.children.find(
    (child: ChildNode) => DomUtils.isTag(child) && (child as Element).name.toLowerCase() === 'code'
  );
  
  if (codeElement) {
    return renderCode(codeElement as Element, context);
  }
  
  // Otherwise, render as code block
  const content = DomUtils.getText(element);
  if (!content.trim()) {
    return '';
  }
  
  return '```\n' + content + '\n```\n\n';
}

/**
 * Render code
 */
function renderCode(element: Element, context: RenderContext): string {
  const content = DomUtils.getText(element);
  if (!content.trim()) {
    return '';
  }
  
  // If parent is pre, render as code block
  const parent = element.parent;
  if (parent && DomUtils.isTag(parent) && parent.name.toLowerCase() === 'pre') {
    return '```\n' + content + '\n```\n\n';
  }
  
  // Otherwise, render as inline code
  return `\`${content}\``;
}

/**
 * Render link
 */
function renderLink(element: Element, context: RenderContext): string {
  const href = element.attribs?.href;
  const content = renderChildren(element, context).trim();
  
  if (!content) {
    return '';
  }
  
  if (!href) {
    // No href, just return text
    return content;
  }
  
  // Typst link format: #link("url")[text]
  return `#link("${href}")[${content}]`;
}

/**
 * Render image
 */
function renderImage(element: Element, context: RenderContext): string {
  const alt = element.attribs?.alt || '';
  
  // In production mode, images are degraded to alt text or empty
  // In debug mode, we can add a comment
  if (context.debug && element.attribs?.src) {
    return `/* Image: ${element.attribs.src} */${alt ? ` ${alt}` : ''}`;
  }
  
  return alt;
}

/**
 * Render span element
 */
function renderSpan(element: Element, context: RenderContext): string {
  // Span can have inline styles
  const style = parseInlineStyle(element.attribs?.style || '');
  const classList = (element.attribs?.class || '').split(' ').filter(Boolean);
  
  let newStyle: StyleContext = {};
  let hasDebugInfo = false;
  const debugMessages: string[] = [];
  
  // Parse Quill.js classes
  for (const className of classList) {
    if (className.startsWith('ql-')) {
      // Quill-specific classes
      if (context.debug) {
        debugMessages.push(`Quill class: ${className}`);
      }
    }
  }
  
  // Parse inline styles
  if (style.fontWeight === 'bold' || style.fontWeight === '700') {
    newStyle.bold = true;
  }
  if (style.fontStyle === 'italic') {
    newStyle.italic = true;
  }
  if (style.color && context.debug) {
    debugMessages.push(`Color: ${style.color}`);
  }
  
  // Report unsupported styles in debug mode
  if (context.debug && debugMessages.length > 0) {
    hasDebugInfo = true;
  }
  
  // Render with or without styling
  if (Object.keys(newStyle).length > 0) {
    return renderWithStyle(element, context, newStyle);
  }
  
  const content = renderChildren(element, context);
  
  if (hasDebugInfo && context.debug) {
    return `/* ${debugMessages.join(', ')} */${content}`;
  }
  
  return content;
}

/**
 * Render element with additional style context
 */
function renderWithStyle(
  element: Element,
  context: RenderContext,
  additionalStyle: StyleContext
): string {
  const newContext: RenderContext = {
    ...context,
    styleStack: [...context.styleStack, additionalStyle],
  };
  
  return renderChildren(element, newContext);
}

/**
 * Render all children of an element
 */
function renderChildren(element: Element, context: RenderContext): string {
  if (!element.children || element.children.length === 0) {
    return '';
  }
  
  return element.children.map((child: ChildNode) => renderNode(child, context)).join('');
}

/**
 * Get current style from style stack
 */
function getCurrentStyle(context: RenderContext): StyleContext {
  const merged: StyleContext = {};
  
  for (const style of context.styleStack) {
    Object.assign(merged, style);
  }
  
  return merged;
}

/**
 * Get Quill.js alignment class
 */
function getQuillAlignment(element: Element): string | null {
  const classList = (element.attribs?.class || '').split(' ');
  
  for (const className of classList) {
    if (className === 'ql-align-center') return 'center';
    if (className === 'ql-align-right') return 'right';
    if (className === 'ql-align-justify') return 'center'; // Typst doesn't have justify, use center
  }
  
  // Check inline style
  const style = parseInlineStyle(element.attribs?.style || '');
  if (style.textAlign === 'center') return 'center';
  if (style.textAlign === 'right') return 'right';
  if (style.textAlign === 'justify') return 'center';
  
  return null;
}

/**
 * Get Quill.js indent level
 */
function getQuillIndent(element: Element): number {
  const classList = (element.attribs?.class || '').split(' ');
  
  for (const className of classList) {
    if (className.startsWith('ql-indent-')) {
      const level = parseInt(className.replace('ql-indent-', ''));
      if (!isNaN(level)) {
        return level;
      }
    }
  }
  
  return 0;
}

/**
 * Parse inline style attribute into object
 */
function parseInlineStyle(styleStr: string): Record<string, string> {
  const result: Record<string, string> = {};
  
  if (!styleStr) {
    return result;
  }
  
  const declarations = styleStr.split(';').filter(Boolean);
  
  for (const declaration of declarations) {
    const [property, value] = declaration.split(':').map(s => s.trim());
    if (property && value) {
      // Convert to camelCase
      const camelProperty = property.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
      result[camelProperty] = value;
    }
  }
  
  return result;
}
