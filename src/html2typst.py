"""
Production-quality HTML to Typst translator.

This module converts HTML (generated by Quill.js) to Typst code.
Key features:
- 100% text preservation guarantee
- Support for Quill.js classes and styles
- Production and debug modes
- Fail-safe design: structure/style may simplify, text never lost
"""

from html.parser import HTMLParser
from typing import Optional, List, Dict, Any, Tuple, TextIO
from dataclasses import dataclass, field
import re
import sys


@dataclass
class RenderContext:
    """Context for rendering HTML nodes to Typst."""
    debug: bool = False
    in_ordered_list: bool = False
    in_pre: bool = False
    list_item_started: bool = False  # Track if we've output the list marker
    log_file: Optional[TextIO] = None  # File handle for debug logging
    
    def log(self, message: str):
        """Write a debug message to the log file if debug mode is enabled."""
        if self.debug and self.log_file:
            self.log_file.write(f"{message}\n")
            self.log_file.flush()
    
    
class HTML2TypstParser(HTMLParser):
    """Parser that converts HTML to Typst."""
    
    def __init__(self, context: RenderContext):
        super().__init__()
        self.context = context
        self.result: List[str] = []
        self.tag_stack: List[Tuple[str, Dict[str, str]]] = []  # (tag, attrs)
        
    def handle_starttag(self, tag: str, attrs: List[Tuple[str, Optional[str]]]):
        """Handle opening HTML tags."""
        attr_dict = {k: v or '' for k, v in attrs}
        self.tag_stack.append((tag, attr_dict))
        
        # Handle tags that produce output at start
        if tag == 'br':
            self.result.append('\\\n')
        elif tag == 'ol':
            self.context.in_ordered_list = True
        elif tag == 'pre':
            self.context.in_pre = True
            self.result.append('```\n')
        elif tag == 'li':
            self.context.list_item_started = False  # Reset for new list item
    
    def handle_endtag(self, tag: str):
        """Handle closing HTML tags."""
        # Find matching opening tag
        for i in range(len(self.tag_stack) - 1, -1, -1):
            if self.tag_stack[i][0] == tag:
                opening_tag, attrs = self.tag_stack.pop(i)
                
                # Handle tags that produce output at end
                if tag in ('p', 'div'):
                    self.result.append('\n\n')
                elif tag in ('h1', 'h2', 'h3', 'h4', 'h5', 'h6'):
                    self.result.append('\n\n')
                elif tag == 'li':
                    self.result.append('\n')
                elif tag == 'blockquote':
                    self.result.append('\n\n')
                elif tag == 'pre':
                    self.result.append('```\n\n')
                    self.context.in_pre = False
                elif tag == 'ol':
                    self.context.in_ordered_list = False
                
                break
    
    def handle_startendtag(self, tag: str, attrs: List[Tuple[str, Optional[str]]]):
        """Handle self-closing tags."""
        attr_dict = {k: v or '' for k, v in attrs}
        
        if tag == 'br':
            self.result.append('\\\n')
        elif tag == 'img':
            alt = attr_dict.get('alt', '')
            src = attr_dict.get('src', '')
            if src:
                if alt:
                    self.result.append(f'#image("{src}", alt: "{alt}")\n\n')
                else:
                    self.result.append(f'#image("{src}")\n\n')
            elif alt:
                self.result.append(alt)
            else:
                self.context.log('Warning: image without src or alt')
    
    def handle_data(self, data: str):
        """Handle text content."""
        if not data.strip():
            return
        
        # Get current context
        text = data
        
        # Check if we need to use function syntax instead of markup syntax
        # This is needed when the previous output ends with ] (from a function call)
        # or * or _ (from markup) to avoid delimiter collision errors in Typst
        use_function_syntax = False
        if self.result and len(self.result) > 0:
            last_stripped = self.result[-1].rstrip() if self.result[-1] else ''
            last_char = last_stripped[-1:] if last_stripped else ''
            # Use function syntax if previous output ends with ], *, or _
            # This prevents patterns like ]*text*, **text*, or __text_
            if last_char in (']', '*', '_'):
                use_function_syntax = True
        
        # Check for nested bold/italic to avoid delimiter collisions
        # If we have both strong and em in the tag stack, we must use function syntax
        # to prevent patterns like *_text_* or _*text*_
        has_strong = any(tag in ('strong', 'b') for tag, _ in self.tag_stack)
        has_em = any(tag in ('em', 'i') for tag, _ in self.tag_stack)
        if has_strong and has_em:
            use_function_syntax = True
        
        # Escape literal asterisks and underscores in plain text
        # Do this BEFORE applying formatting to avoid escaping formatting delimiters
        # Escape backslashes first to avoid double-escaping
        text = text.replace('\\', '\\\\')
        # Escape asterisks and underscores
        text = text.replace('*', r'\*')
        text = text.replace('_', r'\_')
        
        # Apply formatting based on tag stack
        for tag, attrs in reversed(self.tag_stack):
            if tag in ('strong', 'b'):
                if use_function_syntax:
                    text = f'#strong[{text}]'
                else:
                    text = f'*{text}*'
                break
        
        for tag, attrs in reversed(self.tag_stack):
            if tag in ('em', 'i'):
                if use_function_syntax:
                    text = f'#emph[{text}]'
                else:
                    text = f'_{text}_'
                break
        
        # Handle superscript and subscript (must be processed after bold/italic)
        for tag, attrs in reversed(self.tag_stack):
            if tag == 'sup':
                text = f'#super[{text}]'
                break
            elif tag == 'sub':
                text = f'#sub[{text}]'
                break
        
        # Handle headings
        for tag, attrs in reversed(self.tag_stack):
            if tag.startswith('h') and len(tag) == 2 and tag[1].isdigit():
                level = int(tag[1])
                prefix = '=' * level
                text = f'{prefix} {data}'  # Use original data
                break
        
        # Handle list items
        for tag, attrs in reversed(self.tag_stack):
            if tag == 'li':
                # Only add marker if this is the first text in the list item
                if not self.context.list_item_started:
                    # Check for indent
                    classes = attrs.get('class', '').split()
                    indent_level = 0
                    for cls in classes:
                        if cls.startswith('ql-indent-'):
                            try:
                                indent_level = int(cls.replace('ql-indent-', ''))
                            except ValueError:
                                pass
                            break
                    
                    indent = '  ' * indent_level
                    marker = '+' if self.context.in_ordered_list else '-'
                    text = f'{indent}{marker} {text}'
                    self.context.list_item_started = True
                break
        
        # Handle blockquote
        for tag, attrs in reversed(self.tag_stack):
            if tag == 'blockquote':
                text = f'> {text}'
                break
        
        # Handle inline code
        for tag, attrs in reversed(self.tag_stack):
            if tag == 'code' and not self.context.in_pre:
                text = f'`{text}`'
                break
        
        # Handle links
        for tag, attrs in reversed(self.tag_stack):
            if tag == 'a':
                href = attrs.get('href', '')
                if href:
                    text = f'#link("{href}")[{text}]'
                else:
                    self.context.log('Warning: link without href')
                    # text stays as is
                break
        
        # Handle spans with styles
        for tag, attrs in reversed(self.tag_stack):
            if tag == 'span':
                text = self.apply_span_styles(text, attrs)
                break
        
        # Handle paragraph alignment
        for tag, attrs in reversed(self.tag_stack):
            if tag in ('p', 'div', 'li'):
                classes = attrs.get('class', '').split()
                align = None
                for cls in classes:
                    if cls.startswith('ql-align-'):
                        align = cls.replace('ql-align-', '')
                        break
                
                if not align:
                    style_str = attrs.get('style', '')
                    styles = self.parse_inline_styles(style_str)
                    align = styles.get('text-align')
                
                if align in ('center', 'right'):
                    # For list items with alignment, we handle it differently
                    if tag == 'li':
                        # Just note it in debug mode
                        if align not in ('left',):
                            self.context.log(f'Info: list item with alignment: {align}')
                    else:
                        text = f'#align({align})[{text}]'
                elif align and align != 'left':
                    self.context.log(f'Warning: unknown alignment: {align}')
                break
        
        # Add spacing to avoid Typst syntax errors and improve readability
        # After a closing bracket ] or paren ), add a space before most text
        if self.result and len(self.result) > 0:
            last_stripped = self.result[-1].rstrip() if self.result[-1] else ''
            last_char = last_stripped[-1:] if last_stripped else ''
            first_stripped = text.lstrip() if text else ''
            first_char = first_stripped[:1] if first_stripped else ''
            
            # Add space if last char is ] or ) and next text doesn't start with certain safe chars
            # Safe chars after ]: newline, space (already handled by lstrip), and certain punctuation
            if last_char in (']', ')') and first_char and first_char not in ('\n', ',', '.', ';', ':', '!', '?', ')', ']'):
                self.result.append(' ')
        
        self.result.append(text)
    
    def apply_span_styles(self, content: str, attrs: Dict[str, str]) -> str:
        """Apply span styles to content."""
        if not content:
            return ''
        
        classes = attrs.get('class', '').split()
        style_str = attrs.get('style', '')
        styles = self.parse_inline_styles(style_str)
        
        result = content
        wrappers = []
        unsupported = []
        
        # Handle color
        if 'color' in styles:
            color = styles['color']
            if color and color != 'windowtext':
                wrappers.append(f'#text(fill: {color})')
            elif color == 'windowtext':
                unsupported.append(f'color: {color}')
        
        # Handle background-color
        if 'background-color' in styles:
            bgcolor = styles['background-color']
            if bgcolor:
                wrappers.append(f'#highlight(fill: {bgcolor})')
        
        # Handle font-size
        size = None
        for cls in classes:
            if cls.startswith('ql-size-'):
                size = cls.replace('ql-size-', '')
                break
        
        if not size and 'font-size' in styles:
            size = styles['font-size']
        
        if size:
            size_map = {
                'small': '0.75em',
                'large': '1.5em',
                'huge': '2.5em',
            }
            typst_size = size_map.get(size, size)
            wrappers.append(f'#text(size: {typst_size})')
        
        # Handle font-family
        font = None
        for cls in classes:
            if cls.startswith('ql-font-'):
                font = cls.replace('ql-font-', '')
                break
        
        if not font and 'font-family' in styles:
            font = styles['font-family']
        
        if font:
            font = font.strip('\'"')
            wrappers.append(f'#text(font: "{font}")')
        
        # Handle font-weight (bold)
        if 'font-weight' in styles:
            weight = styles['font-weight']
            if weight in ('bold', '700', '800', '900'):
                result = f'*{result}*'
            else:
                unsupported.append(f'font-weight: {weight}')
        
        # Handle font-style (italic)
        if 'font-style' in styles:
            style = styles['font-style']
            if style == 'italic':
                result = f'_{result}_'
            else:
                unsupported.append(f'font-style: {style}')
        
        # Apply wrappers
        for wrapper in reversed(wrappers):
            result = f'{wrapper}[{result}]'
        
        # Log unsupported styles
        if unsupported:
            self.context.log(f'Warning: unsupported styles: {", ".join(unsupported)}')
        
        return result
    
    def parse_inline_styles(self, style_str: str) -> Dict[str, str]:
        """Parse inline style string to dictionary."""
        styles = {}
        if not style_str:
            return styles
        
        for part in style_str.split(';'):
            if ':' in part:
                key, value = part.split(':', 1)
                styles[key.strip().lower()] = value.strip()
        return styles
    
    def get_output(self) -> str:
        """Get the final Typst output."""
        return ''.join(self.result)


def translate_html_to_typst(html: str, debug: bool = False, log_file: Optional[str] = None) -> str:
    """
    Translate HTML (generated by Quill.js) to Typst code.
    
    Args:
        html: HTML string to convert
        debug: If True, write debug messages to log file (if log_file is provided)
        log_file: Optional path to log file for debug messages. If not provided and debug=True,
                  logs will be written to 'html2typst_debug.log' in the current directory.
    
    Returns:
        Typst code as a string
    
    Examples:
        >>> translate_html_to_typst("<p>Hello <strong>world</strong></p>")
        'Hello *world*\\n\\n'
        
        >>> translate_html_to_typst("<h1>Title</h1><p>Content</p>")
        '= Title\\n\\nContent\\n\\n'
        
        >>> translate_html_to_typst("<custom>Test</custom>", debug=True, log_file="debug.log")
        'Test\\n\\n'
        # Debug messages written to debug.log
    """
    # Determine log file path
    log_file_handle = None
    should_close_log = False
    
    if debug:
        if log_file is None:
            log_file = 'html2typst_debug.log'
        
        try:
            log_file_handle = open(log_file, 'w', encoding='utf-8')
            should_close_log = True
        except IOError as e:
            # If we can't open the log file, write to stderr instead
            print(f"Warning: Could not open log file '{log_file}': {e}", file=sys.stderr)
            log_file_handle = None
    
    # Create rendering context
    context = RenderContext(debug=debug, log_file=log_file_handle)
    
    try:
        # Create parser
        parser = HTML2TypstParser(context)
        
        # Parse HTML
        parser.feed(html)
        parser.close()
        
        # Get output
        result = parser.get_output()
        
        # Clean up excessive newlines (but preserve structure)
        result = re.sub(r'\n{4,}', '\n\n\n', result)
        
        return result
    finally:
        # Close log file if we opened it
        if should_close_log and log_file_handle:
            log_file_handle.close()
